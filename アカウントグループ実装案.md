# アカウントグループ機能 実装案

## 要件整理

1. アカウントグループを作成できる
2. グループメンバーは他のアカウントを招待できる
3. 招待されたアカウントは承諾して参加できる
4. ホーム画面にアカウントグループ切り替えボタンを実装
5. アカウントグループごとに行きたいところグループ（Group）と行きたいところ（Item）を持つ
6. 個人の状態も残す（「自分のみ」の項目が常に存在）

---

## 実装案1: シンプルな多対多関係モデル

### 設計思想

- アカウントグループを独立したエンティティとして管理
- ItemとGroupに`accountGroupId`を追加してグループごとに分離
- 個人用データは`accountGroupId = null`で管理

### データベーススキーマ

```prisma
// アカウントグループ
model AccountGroup {
  id          String   @id @default(uuid())
  name        String
  description String?
  createdBy   String   @map("created_by")  // 作成者ID
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // リレーション
  members     AccountGroupMember[]
  invitations AccountGroupInvitation[]
  items       Item[]
  groups      Group[]

  @@map("account_groups")
  @@index([createdBy])
}

// アカウントグループメンバー（多対多）
model AccountGroupMember {
  id            String   @id @default(uuid())
  accountGroupId String  @map("account_group_id")
  userId        String   @map("user_id")
  role          String   @default("member") // "owner", "admin", "member"
  joinedAt      DateTime @default(now()) @map("joined_at")

  accountGroup AccountGroup @relation(fields: [accountGroupId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account_group_members")
  @@unique([accountGroupId, userId])
  @@index([accountGroupId])
  @@index([userId])
}

// アカウントグループ招待
model AccountGroupInvitation {
  id            String   @id @default(uuid())
  accountGroupId String  @map("account_group_id")
  inviterId     String   @map("inviter_id")  // 招待した人のID
  inviteeId     String   @map("invitee_id")  // 招待された人のID
  status        String   @default("pending") // "pending", "accepted", "rejected", "expired"
  expiresAt     DateTime? @map("expires_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  accountGroup AccountGroup @relation(fields: [accountGroupId], references: [id], onDelete: Cascade)
  inviter      User         @relation("Inviter", fields: [inviterId], references: [id], onDelete: Cascade)
  invitee      User         @relation("Invitee", fields: [inviteeId], references: [id], onDelete: Cascade)

  @@map("account_group_invitations")
  @@index([accountGroupId])
  @@index([inviteeId])
  @@index([status])
}

// 既存モデルの拡張
model User {
  // ... 既存フィールド
  accountGroupMembers AccountGroupMember[]
  sentInvitations     AccountGroupInvitation[] @relation("Inviter")
  receivedInvitations AccountGroupInvitation[] @relation("Invitee")
}

model Item {
  // ... 既存フィールド
  accountGroupId String? @map("account_group_id")  // null = 個人用
  accountGroup   AccountGroup? @relation(fields: [accountGroupId], references: [id], onDelete: SetNull)

  @@index([accountGroupId])
}

model Group {
  // ... 既存フィールド
  accountGroupId String? @map("account_group_id")  // null = 個人用
  accountGroup   AccountGroup? @relation(fields: [accountGroupId], references: [id], onDelete: SetNull)

  @@index([accountGroupId])
}
```

### 特徴

**メリット:**

- シンプルで理解しやすい構造
- 個人データとグループデータを同じテーブルで管理（`accountGroupId`で分離）
- クエリが比較的シンプル

**デメリット:**

- 個人用データも`accountGroupId = null`で管理する必要がある
- 「自分のみ」を特別扱いする必要がある（仮想的なアカウントグループとして扱う）

### フロントエンド実装

```typescript
// アカウントグループ切り替えコンポーネント
type AccountGroupSelector = {
  currentAccountGroupId: string | null // null = "自分のみ"
  accountGroups: Array<{
    id: string | null
    name: string
    memberCount: number
  }>
  onSwitch: (accountGroupId: string | null) => void
}

// API呼び出し例
// 個人用: GET /api/items?accountGroupId=null
// グループ用: GET /api/items?accountGroupId=xxx
```

### 実装のポイント

1. **「自分のみ」の扱い**
   - `accountGroupId = null`を「自分のみ」として扱う
   - 切り替えボタンには常に`{ id: null, name: "自分のみ" }`を含める

2. **データ取得**
   - 現在選択中のアカウントグループIDに基づいてItem/Groupをフィルタリング
   - 個人用: `WHERE accountGroupId IS NULL AND userId = ?`
   - グループ用: `WHERE accountGroupId = ?`

3. **招待フロー**
   - メンバーが招待を送信 → `AccountGroupInvitation`作成
   - 招待されたユーザーが承諾 → `AccountGroupMember`作成、`AccountGroupInvitation.status = "accepted"`

---

## 実装案2: 個人用デフォルトグループモデル

### 設計思想

- 各ユーザーに自動的に個人用アカウントグループを作成
- すべてのデータをアカウントグループに紐づける
- 「自分のみ」も正式なアカウントグループとして扱う

### データベーススキーマ

```prisma
// アカウントグループ
model AccountGroup {
  id          String   @id @default(uuid())
  name        String
  description String?
  type        String   @default("shared") // "personal", "shared"
  createdBy   String   @map("created_by")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  members     AccountGroupMember[]
  invitations AccountGroupInvitation[]
  items       Item[]
  groups      Group[]

  @@map("account_groups")
  @@index([createdBy])
  @@index([type])
}

// アカウントグループメンバー（多対多）
model AccountGroupMember {
  id            String   @id @default(uuid())
  accountGroupId String  @map("account_group_id")
  userId        String   @map("user_id")
  role          String   @default("member") // "owner", "admin", "member"
  joinedAt      DateTime @default(now()) @map("joined_at")

  accountGroup AccountGroup @relation(fields: [accountGroupId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account_group_members")
  @@unique([accountGroupId, userId])
  @@index([accountGroupId])
  @@index([userId])
}

// アカウントグループ招待
model AccountGroupInvitation {
  id            String   @id @default(uuid())
  accountGroupId String  @map("account_group_id")
  inviterId     String   @map("inviter_id")
  inviteeId     String   @map("invitee_id")
  status        String   @default("pending")
  expiresAt     DateTime? @map("expires_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  accountGroup AccountGroup @relation(fields: [accountGroupId], references: [id], onDelete: Cascade)
  inviter      User         @relation("Inviter", fields: [inviterId], references: [id], onDelete: Cascade)
  invitee      User         @relation("Invitee", fields: [inviteeId], references: [id], onDelete: Cascade)

  @@map("account_group_invitations")
  @@index([accountGroupId])
  @@index([inviteeId])
  @@index([status])
}

// 既存モデルの拡張
model User {
  // ... 既存フィールド
  accountGroupMembers AccountGroupMember[]
  sentInvitations     AccountGroupInvitation[] @relation("Inviter")
  receivedInvitations AccountGroupInvitation[] @relation("Invitee")
  personalAccountGroup AccountGroup? // 個人用グループへの参照（オプション）
}

model Item {
  // ... 既存フィールド
  accountGroupId String @map("account_group_id")  // NOT NULL（必須）
  accountGroup   AccountGroup @relation(fields: [accountGroupId], references: [id], onDelete: Cascade)

  @@index([accountGroupId])
}

model Group {
  // ... 既存フィールド
  accountGroupId String @map("account_group_id")  // NOT NULL（必須）
  accountGroup   AccountGroup @relation(fields: [accountGroupId], references: [id], onDelete: Cascade)

  @@index([accountGroupId])
}
```

### 特徴

**メリット:**

- すべてのデータが一貫してアカウントグループに紐づく
- 個人用も正式なグループとして扱えるため、ロジックが統一される
- `type`フィールドで個人用/共有用を区別可能

**デメリット:**

- ユーザー作成時に個人用グループを自動生成する必要がある
- 既存データのマイグレーションが必要（既存Item/Groupに個人用グループを割り当て）

### フロントエンド実装

```typescript
// アカウントグループ切り替えコンポーネント
type AccountGroupSelector = {
  currentAccountGroupId: string
  accountGroups: Array<{
    id: string
    name: string
    type: 'personal' | 'shared'
    memberCount: number
  }>
  onSwitch: (accountGroupId: string) => void
}

// API呼び出し例
// すべて: GET /api/items?accountGroupId=xxx
// 個人用グループは type="personal" で識別
```

### 実装のポイント

1. **個人用グループの自動生成**
   - ユーザー登録時に`type="personal"`のアカウントグループを自動作成
   - 作成者を唯一のメンバーとして追加

2. **データ取得**
   - 現在選択中のアカウントグループIDでItem/Groupをフィルタリング
   - `WHERE accountGroupId = ?`

3. **招待フロー**
   - 案1と同様

4. **既存データのマイグレーション**
   - 既存のItem/Groupに対して、各ユーザーの個人用グループを割り当て
   - マイグレーションスクリプトで一括処理

---

## 比較表

| 項目                   | 案1: null値モデル    | 案2: デフォルトグループモデル |
| ---------------------- | -------------------- | ----------------------------- |
| **スキーマの複雑さ**   | シンプル（null許可） | やや複雑（NOT NULL制約）      |
| **データの一貫性**     | 個人データはnull     | すべてグループに紐づく        |
| **クエリの複雑さ**     | nullチェック必要     | シンプル                      |
| **既存データ移行**     | 不要                 | 必要（個人用グループ作成）    |
| **「自分のみ」の扱い** | 特別扱い（null）     | 正式なグループ                |
| **実装の容易さ**       | やや容易             | やや複雑                      |

---

## 推奨案

**案1（null値モデル）を推奨**

**理由:**

1. 既存データへの影響が少ない（マイグレーション不要）
2. 実装がシンプルで理解しやすい
3. 「自分のみ」を特別扱いするロジックは追加できる
4. パフォーマンス面でも大きな差はない

**ただし、以下の点に注意:**

- `accountGroupId`がnullの場合のクエリを適切に書く
- フロントエンドで「自分のみ」を適切に表示する
- APIで`accountGroupId=null`を適切に処理する

---

## 実装手順（案1を採用した場合）

### 1. データベーススキーマ更新

- `AccountGroup`, `AccountGroupMember`, `AccountGroupInvitation`モデルを追加
- `Item`, `Group`に`accountGroupId`を追加（nullable）

### 2. バックエンドAPI実装

- アカウントグループCRUD
- 招待送信/承諾/拒否API
- Item/Group取得時に`accountGroupId`でフィルタリング

### 3. フロントエンド実装

- アカウントグループ切り替えコンポーネント
- ホーム画面に切り替えボタンを追加
- 招待管理UI

### 4. 既存機能の調整

- Item/Group作成時に現在のアカウントグループIDを設定
- 個人用は`accountGroupId = null`を設定
